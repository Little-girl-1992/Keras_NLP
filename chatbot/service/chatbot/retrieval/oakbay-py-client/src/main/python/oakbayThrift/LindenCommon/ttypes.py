#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class LindenType:
  STRING = 0
  INTEGER = 1
  LONG = 2
  DOUBLE = 3
  FLOAT = 4
  FACET = 5

  _VALUES_TO_NAMES = {
    0: "STRING",
    1: "INTEGER",
    2: "LONG",
    3: "DOUBLE",
    4: "FLOAT",
    5: "FACET",
  }

  _NAMES_TO_VALUES = {
    "STRING": 0,
    "INTEGER": 1,
    "LONG": 2,
    "DOUBLE": 3,
    "FLOAT": 4,
    "FACET": 5,
  }


class LindenFieldSchema:
  """
  Attributes:
   - name
   - type
   - stored
   - tokenized
   - indexed
   - omitNorms
   - snippet
   - docValues
   - multi
   - omitFreqs
   - listCache
   - dynamicSchema
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'type', None,     0, ), # 2
    (3, TType.BOOL, 'stored', None, False, ), # 3
    (4, TType.BOOL, 'tokenized', None, False, ), # 4
    (5, TType.BOOL, 'indexed', None, False, ), # 5
    (6, TType.BOOL, 'omitNorms', None, False, ), # 6
    (7, TType.BOOL, 'snippet', None, False, ), # 7
    (8, TType.BOOL, 'docValues', None, False, ), # 8
    (9, TType.BOOL, 'multi', None, False, ), # 9
    (10, TType.BOOL, 'omitFreqs', None, False, ), # 10
    (11, TType.BOOL, 'listCache', None, False, ), # 11
    (12, TType.BOOL, 'dynamicSchema', None, False, ), # 12
  )

  def __init__(self, name=None, type=thrift_spec[2][4], stored=thrift_spec[3][4], tokenized=thrift_spec[4][4], indexed=thrift_spec[5][4], omitNorms=thrift_spec[6][4], snippet=thrift_spec[7][4], docValues=thrift_spec[8][4], multi=thrift_spec[9][4], omitFreqs=thrift_spec[10][4], listCache=thrift_spec[11][4], dynamicSchema=thrift_spec[12][4],):
    self.name = name
    self.type = type
    self.stored = stored
    self.tokenized = tokenized
    self.indexed = indexed
    self.omitNorms = omitNorms
    self.snippet = snippet
    self.docValues = docValues
    self.multi = multi
    self.omitFreqs = omitFreqs
    self.listCache = listCache
    self.dynamicSchema = dynamicSchema

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.stored = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.tokenized = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.indexed = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.omitNorms = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.snippet = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.docValues = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.multi = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.omitFreqs = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.listCache = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.dynamicSchema = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenFieldSchema')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.stored != None:
      oprot.writeFieldBegin('stored', TType.BOOL, 3)
      oprot.writeBool(self.stored)
      oprot.writeFieldEnd()
    if self.tokenized != None:
      oprot.writeFieldBegin('tokenized', TType.BOOL, 4)
      oprot.writeBool(self.tokenized)
      oprot.writeFieldEnd()
    if self.indexed != None:
      oprot.writeFieldBegin('indexed', TType.BOOL, 5)
      oprot.writeBool(self.indexed)
      oprot.writeFieldEnd()
    if self.omitNorms != None:
      oprot.writeFieldBegin('omitNorms', TType.BOOL, 6)
      oprot.writeBool(self.omitNorms)
      oprot.writeFieldEnd()
    if self.snippet != None:
      oprot.writeFieldBegin('snippet', TType.BOOL, 7)
      oprot.writeBool(self.snippet)
      oprot.writeFieldEnd()
    if self.docValues != None:
      oprot.writeFieldBegin('docValues', TType.BOOL, 8)
      oprot.writeBool(self.docValues)
      oprot.writeFieldEnd()
    if self.multi != None:
      oprot.writeFieldBegin('multi', TType.BOOL, 9)
      oprot.writeBool(self.multi)
      oprot.writeFieldEnd()
    if self.omitFreqs != None:
      oprot.writeFieldBegin('omitFreqs', TType.BOOL, 10)
      oprot.writeBool(self.omitFreqs)
      oprot.writeFieldEnd()
    if self.listCache != None:
      oprot.writeFieldBegin('listCache', TType.BOOL, 11)
      oprot.writeBool(self.listCache)
      oprot.writeFieldEnd()
    if self.dynamicSchema != None:
      oprot.writeFieldBegin('dynamicSchema', TType.BOOL, 12)
      oprot.writeBool(self.dynamicSchema)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.name is None:
        raise TProtocol.TProtocolException(message='Required field name is unset!')
      if self.type is None:
        raise TProtocol.TProtocolException(message='Required field type is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenSchema:
  """
  Attributes:
   - id
   - fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.LIST, 'fields', (TType.STRUCT,(LindenFieldSchema, LindenFieldSchema.thrift_spec)), None, ), # 2
  )

  def __init__(self, id=None, fields=None,):
    self.id = id
    self.fields = fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.fields = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = LindenFieldSchema()
            _elem5.read(iprot)
            self.fields.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenSchema')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter6 in self.fields:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.id is None:
        raise TProtocol.TProtocolException(message='Required field id is unset!')
      if self.fields is None:
        raise TProtocol.TProtocolException(message='Required field fields is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenExplanation:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenExplanation')
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenExplanation:
  """
  Attributes:
   - value
   - description
   - details
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'value', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
    (3, TType.LIST, 'details', (TType.STRUCT,(LindenExplanation, LindenExplanation.thrift_spec)), None, ), # 3
  )

  def __init__(self, value=None, description=None, details=None,):
    self.value = value
    self.description = description
    self.details = details

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.details = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = LindenExplanation()
            _elem12.read(iprot)
            self.details.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenExplanation')
    if self.value != None:
      oprot.writeFieldBegin('value', TType.DOUBLE, 1)
      oprot.writeDouble(self.value)
      oprot.writeFieldEnd()
    if self.description != None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.details != None:
      oprot.writeFieldBegin('details', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.details))
      for iter13 in self.details:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.value is None:
        raise TProtocol.TProtocolException(message='Required field value is unset!')
      if self.description is None:
        raise TProtocol.TProtocolException(message='Required field description is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenSnippet:
  """
  Attributes:
   - snippet
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'snippet', None, None, ), # 1
  )

  def __init__(self, snippet=None,):
    self.snippet = snippet

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.snippet = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenSnippet')
    if self.snippet != None:
      oprot.writeFieldBegin('snippet', TType.STRING, 1)
      oprot.writeString(self.snippet)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.snippet is None:
        raise TProtocol.TProtocolException(message='Required field snippet is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenHit:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenHit')
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenHit:
  """
  Attributes:
   - id
   - score
   - source
   - distance
   - explanation
   - fields
   - snippets
   - groupHits
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.DOUBLE, 'score', None, None, ), # 2
    (3, TType.STRING, 'source', None, None, ), # 3
    (4, TType.DOUBLE, 'distance', None, None, ), # 4
    (5, TType.STRUCT, 'explanation', (LindenExplanation, LindenExplanation.thrift_spec), None, ), # 5
    (6, TType.MAP, 'fields', (TType.STRING,None,TType.STRING,None), None, ), # 6
    (7, TType.MAP, 'snippets', (TType.STRING,None,TType.STRUCT,(LindenSnippet, LindenSnippet.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'groupHits', (TType.STRUCT,(LindenHit, LindenHit.thrift_spec)), None, ), # 8
  )

  def __init__(self, id=None, score=None, source=None, distance=None, explanation=None, fields=None, snippets=None, groupHits=None,):
    self.id = id
    self.score = score
    self.source = source
    self.distance = distance
    self.explanation = explanation
    self.fields = fields
    self.snippets = snippets
    self.groupHits = groupHits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.score = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.distance = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.explanation = LindenExplanation()
          self.explanation.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.fields = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          for _i18 in xrange(_size14):
            _key19 = iprot.readString();
            _val20 = iprot.readString();
            self.fields[_key19] = _val20
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.snippets = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin() 
          for _i25 in xrange(_size21):
            _key26 = iprot.readString();
            _val27 = LindenSnippet()
            _val27.read(iprot)
            self.snippets[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.groupHits = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = LindenHit()
            _elem33.read(iprot)
            self.groupHits.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenHit')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.score != None:
      oprot.writeFieldBegin('score', TType.DOUBLE, 2)
      oprot.writeDouble(self.score)
      oprot.writeFieldEnd()
    if self.source != None:
      oprot.writeFieldBegin('source', TType.STRING, 3)
      oprot.writeString(self.source)
      oprot.writeFieldEnd()
    if self.distance != None:
      oprot.writeFieldBegin('distance', TType.DOUBLE, 4)
      oprot.writeDouble(self.distance)
      oprot.writeFieldEnd()
    if self.explanation != None:
      oprot.writeFieldBegin('explanation', TType.STRUCT, 5)
      self.explanation.write(oprot)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.fields))
      for kiter34,viter35 in self.fields.items():
        oprot.writeString(kiter34)
        oprot.writeString(viter35)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.snippets != None:
      oprot.writeFieldBegin('snippets', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.snippets))
      for kiter36,viter37 in self.snippets.items():
        oprot.writeString(kiter36)
        viter37.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.groupHits != None:
      oprot.writeFieldBegin('groupHits', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.groupHits))
      for iter38 in self.groupHits:
        iter38.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.id is None:
        raise TProtocol.TProtocolException(message='Required field id is unset!')
      if self.score is None:
        raise TProtocol.TProtocolException(message='Required field score is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryInfo:
  """
  Attributes:
   - query
   - filter
   - sort
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'query', None, None, ), # 1
    (2, TType.STRING, 'filter', None, None, ), # 2
    (3, TType.STRING, 'sort', None, None, ), # 3
  )

  def __init__(self, query=None, filter=None, sort=None,):
    self.query = query
    self.filter = filter
    self.sort = sort

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.query = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filter = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sort = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryInfo')
    if self.query != None:
      oprot.writeFieldBegin('query', TType.STRING, 1)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 2)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.sort != None:
      oprot.writeFieldBegin('sort', TType.STRING, 3)
      oprot.writeString(self.sort)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.query is None:
        raise TProtocol.TProtocolException(message='Required field query is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenLabelAndValue:
  """
  Attributes:
   - label
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'label', None, None, ), # 1
    (2, TType.I32, 'value', None, None, ), # 2
  )

  def __init__(self, label=None, value=None,):
    self.label = label
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.label = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenLabelAndValue')
    if self.label != None:
      oprot.writeFieldBegin('label', TType.STRING, 1)
      oprot.writeString(self.label)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.I32, 2)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.label is None:
        raise TProtocol.TProtocolException(message='Required field label is unset!')
      if self.value is None:
        raise TProtocol.TProtocolException(message='Required field value is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenFacetResult:
  """
  Attributes:
   - dim
   - path
   - value
   - childCount
   - labelValues
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dim', None, None, ), # 1
    (2, TType.STRING, 'path', None, None, ), # 2
    (3, TType.I32, 'value', None, 0, ), # 3
    (4, TType.I32, 'childCount', None, 0, ), # 4
    (5, TType.LIST, 'labelValues', (TType.STRUCT,(LindenLabelAndValue, LindenLabelAndValue.thrift_spec)), None, ), # 5
  )

  def __init__(self, dim=None, path=None, value=thrift_spec[3][4], childCount=thrift_spec[4][4], labelValues=None,):
    self.dim = dim
    self.path = path
    self.value = value
    self.childCount = childCount
    self.labelValues = labelValues

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dim = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.childCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.labelValues = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = LindenLabelAndValue()
            _elem44.read(iprot)
            self.labelValues.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenFacetResult')
    if self.dim != None:
      oprot.writeFieldBegin('dim', TType.STRING, 1)
      oprot.writeString(self.dim)
      oprot.writeFieldEnd()
    if self.path != None:
      oprot.writeFieldBegin('path', TType.STRING, 2)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.I32, 3)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    if self.childCount != None:
      oprot.writeFieldBegin('childCount', TType.I32, 4)
      oprot.writeI32(self.childCount)
      oprot.writeFieldEnd()
    if self.labelValues != None:
      oprot.writeFieldBegin('labelValues', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.labelValues))
      for iter45 in self.labelValues:
        iter45.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.dim is None:
        raise TProtocol.TProtocolException(message='Required field dim is unset!')
      if self.value is None:
        raise TProtocol.TProtocolException(message='Required field value is unset!')
      if self.childCount is None:
        raise TProtocol.TProtocolException(message='Required field childCount is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AggregationResult:
  """
  Attributes:
   - field
   - labelValues
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'field', None, None, ), # 1
    (2, TType.LIST, 'labelValues', (TType.STRUCT,(LindenLabelAndValue, LindenLabelAndValue.thrift_spec)), None, ), # 2
  )

  def __init__(self, field=None, labelValues=None,):
    self.field = field
    self.labelValues = labelValues

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.labelValues = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = LindenLabelAndValue()
            _elem51.read(iprot)
            self.labelValues.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AggregationResult')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.STRING, 1)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    if self.labelValues != None:
      oprot.writeFieldBegin('labelValues', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.labelValues))
      for iter52 in self.labelValues:
        iter52.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.field is None:
        raise TProtocol.TProtocolException(message='Required field field is unset!')
      if self.labelValues is None:
        raise TProtocol.TProtocolException(message='Required field labelValues is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenResult:
  """
  Attributes:
   - success
   - error
   - hits
   - totalHits
   - cost
   - queryInfo
   - facetResults
   - totalGroups
   - totalGroupHits
   - aggregationResults
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, True, ), # 1
    (2, TType.STRING, 'error', None, None, ), # 2
    (3, TType.LIST, 'hits', (TType.STRUCT,(LindenHit, LindenHit.thrift_spec)), None, ), # 3
    (4, TType.I32, 'totalHits', None, None, ), # 4
    (5, TType.I32, 'cost', None, None, ), # 5
    (6, TType.STRUCT, 'queryInfo', (QueryInfo, QueryInfo.thrift_spec), None, ), # 6
    (7, TType.LIST, 'facetResults', (TType.STRUCT,(LindenFacetResult, LindenFacetResult.thrift_spec)), None, ), # 7
    (8, TType.I32, 'totalGroups', None, None, ), # 8
    (9, TType.I32, 'totalGroupHits', None, None, ), # 9
    (10, TType.LIST, 'aggregationResults', (TType.STRUCT,(AggregationResult, AggregationResult.thrift_spec)), None, ), # 10
  )

  def __init__(self, success=thrift_spec[1][4], error=None, hits=None, totalHits=None, cost=None, queryInfo=None, facetResults=None, totalGroups=None, totalGroupHits=None, aggregationResults=None,):
    self.success = success
    self.error = error
    self.hits = hits
    self.totalHits = totalHits
    self.cost = cost
    self.queryInfo = queryInfo
    self.facetResults = facetResults
    self.totalGroups = totalGroups
    self.totalGroupHits = totalGroupHits
    self.aggregationResults = aggregationResults

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.error = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.hits = []
          (_etype56, _size53) = iprot.readListBegin()
          for _i57 in xrange(_size53):
            _elem58 = LindenHit()
            _elem58.read(iprot)
            self.hits.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.totalHits = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cost = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.queryInfo = QueryInfo()
          self.queryInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.facetResults = []
          (_etype62, _size59) = iprot.readListBegin()
          for _i63 in xrange(_size59):
            _elem64 = LindenFacetResult()
            _elem64.read(iprot)
            self.facetResults.append(_elem64)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.totalGroups = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.totalGroupHits = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.aggregationResults = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = AggregationResult()
            _elem70.read(iprot)
            self.aggregationResults.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenResult')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRING, 2)
      oprot.writeString(self.error)
      oprot.writeFieldEnd()
    if self.hits != None:
      oprot.writeFieldBegin('hits', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.hits))
      for iter71 in self.hits:
        iter71.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.totalHits != None:
      oprot.writeFieldBegin('totalHits', TType.I32, 4)
      oprot.writeI32(self.totalHits)
      oprot.writeFieldEnd()
    if self.cost != None:
      oprot.writeFieldBegin('cost', TType.I32, 5)
      oprot.writeI32(self.cost)
      oprot.writeFieldEnd()
    if self.queryInfo != None:
      oprot.writeFieldBegin('queryInfo', TType.STRUCT, 6)
      self.queryInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.facetResults != None:
      oprot.writeFieldBegin('facetResults', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.facetResults))
      for iter72 in self.facetResults:
        iter72.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.totalGroups != None:
      oprot.writeFieldBegin('totalGroups', TType.I32, 8)
      oprot.writeI32(self.totalGroups)
      oprot.writeFieldEnd()
    if self.totalGroupHits != None:
      oprot.writeFieldBegin('totalGroupHits', TType.I32, 9)
      oprot.writeI32(self.totalGroupHits)
      oprot.writeFieldEnd()
    if self.aggregationResults != None:
      oprot.writeFieldBegin('aggregationResults', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.aggregationResults))
      for iter73 in self.aggregationResults:
        iter73.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.success is None:
        raise TProtocol.TProtocolException(message='Required field success is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CacheInfo:
  """
  Attributes:
   - hitRate
   - hitCount
   - missCount
   - loadSuccessCount
   - loadExceptionCount
   - totalLoadTime
   - missRate
   - averageLoadPenalty
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'hitRate', None, None, ), # 1
    (2, TType.I64, 'hitCount', None, None, ), # 2
    (3, TType.I64, 'missCount', None, None, ), # 3
    (4, TType.I64, 'loadSuccessCount', None, None, ), # 4
    (5, TType.I64, 'loadExceptionCount', None, None, ), # 5
    (6, TType.I64, 'totalLoadTime', None, None, ), # 6
    (7, TType.DOUBLE, 'missRate', None, None, ), # 7
    (8, TType.DOUBLE, 'averageLoadPenalty', None, None, ), # 8
  )

  def __init__(self, hitRate=None, hitCount=None, missCount=None, loadSuccessCount=None, loadExceptionCount=None, totalLoadTime=None, missRate=None, averageLoadPenalty=None,):
    self.hitRate = hitRate
    self.hitCount = hitCount
    self.missCount = missCount
    self.loadSuccessCount = loadSuccessCount
    self.loadExceptionCount = loadExceptionCount
    self.totalLoadTime = totalLoadTime
    self.missRate = missRate
    self.averageLoadPenalty = averageLoadPenalty

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.hitRate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.hitCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.missCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.loadSuccessCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.loadExceptionCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.totalLoadTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.missRate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.averageLoadPenalty = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CacheInfo')
    if self.hitRate != None:
      oprot.writeFieldBegin('hitRate', TType.DOUBLE, 1)
      oprot.writeDouble(self.hitRate)
      oprot.writeFieldEnd()
    if self.hitCount != None:
      oprot.writeFieldBegin('hitCount', TType.I64, 2)
      oprot.writeI64(self.hitCount)
      oprot.writeFieldEnd()
    if self.missCount != None:
      oprot.writeFieldBegin('missCount', TType.I64, 3)
      oprot.writeI64(self.missCount)
      oprot.writeFieldEnd()
    if self.loadSuccessCount != None:
      oprot.writeFieldBegin('loadSuccessCount', TType.I64, 4)
      oprot.writeI64(self.loadSuccessCount)
      oprot.writeFieldEnd()
    if self.loadExceptionCount != None:
      oprot.writeFieldBegin('loadExceptionCount', TType.I64, 5)
      oprot.writeI64(self.loadExceptionCount)
      oprot.writeFieldEnd()
    if self.totalLoadTime != None:
      oprot.writeFieldBegin('totalLoadTime', TType.I64, 6)
      oprot.writeI64(self.totalLoadTime)
      oprot.writeFieldEnd()
    if self.missRate != None:
      oprot.writeFieldBegin('missRate', TType.DOUBLE, 7)
      oprot.writeDouble(self.missRate)
      oprot.writeFieldEnd()
    if self.averageLoadPenalty != None:
      oprot.writeFieldBegin('averageLoadPenalty', TType.DOUBLE, 8)
      oprot.writeDouble(self.averageLoadPenalty)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.hitRate is None:
        raise TProtocol.TProtocolException(message='Required field hitRate is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JVMInfo:
  """
  Attributes:
   - totalMemory
   - freeMemory
   - maxMemory
   - arguments
   - gcCount
   - gcTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'totalMemory', None, None, ), # 1
    (2, TType.I64, 'freeMemory', None, None, ), # 2
    (3, TType.I64, 'maxMemory', None, None, ), # 3
    (4, TType.STRING, 'arguments', None, None, ), # 4
    (5, TType.I32, 'gcCount', None, None, ), # 5
    (6, TType.I64, 'gcTime', None, None, ), # 6
  )

  def __init__(self, totalMemory=None, freeMemory=None, maxMemory=None, arguments=None, gcCount=None, gcTime=None,):
    self.totalMemory = totalMemory
    self.freeMemory = freeMemory
    self.maxMemory = maxMemory
    self.arguments = arguments
    self.gcCount = gcCount
    self.gcTime = gcTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.totalMemory = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.freeMemory = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.maxMemory = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.arguments = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.gcCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.gcTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JVMInfo')
    if self.totalMemory != None:
      oprot.writeFieldBegin('totalMemory', TType.I64, 1)
      oprot.writeI64(self.totalMemory)
      oprot.writeFieldEnd()
    if self.freeMemory != None:
      oprot.writeFieldBegin('freeMemory', TType.I64, 2)
      oprot.writeI64(self.freeMemory)
      oprot.writeFieldEnd()
    if self.maxMemory != None:
      oprot.writeFieldBegin('maxMemory', TType.I64, 3)
      oprot.writeI64(self.maxMemory)
      oprot.writeFieldEnd()
    if self.arguments != None:
      oprot.writeFieldBegin('arguments', TType.STRING, 4)
      oprot.writeString(self.arguments)
      oprot.writeFieldEnd()
    if self.gcCount != None:
      oprot.writeFieldBegin('gcCount', TType.I32, 5)
      oprot.writeI32(self.gcCount)
      oprot.writeFieldEnd()
    if self.gcTime != None:
      oprot.writeFieldBegin('gcTime', TType.I64, 6)
      oprot.writeI64(self.gcTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FileDiskUsageInfo:
  """
  Attributes:
   - dirName
   - diskUsage
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dirName', None, None, ), # 1
    (2, TType.I64, 'diskUsage', None, None, ), # 2
  )

  def __init__(self, dirName=None, diskUsage=None,):
    self.dirName = dirName
    self.diskUsage = diskUsage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dirName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.diskUsage = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FileDiskUsageInfo')
    if self.dirName != None:
      oprot.writeFieldBegin('dirName', TType.STRING, 1)
      oprot.writeString(self.dirName)
      oprot.writeFieldEnd()
    if self.diskUsage != None:
      oprot.writeFieldBegin('diskUsage', TType.I64, 2)
      oprot.writeI64(self.diskUsage)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.dirName is None:
        raise TProtocol.TProtocolException(message='Required field dirName is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LindenServiceInfo:
  """
  Attributes:
   - docsNum
   - cacheInfo
   - jvmInfo
   - indexNames
   - fileUsedInfos
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'docsNum', None, None, ), # 1
    (2, TType.STRUCT, 'cacheInfo', (CacheInfo, CacheInfo.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'jvmInfo', (JVMInfo, JVMInfo.thrift_spec), None, ), # 3
    (4, TType.LIST, 'indexNames', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'fileUsedInfos', (TType.STRUCT,(FileDiskUsageInfo, FileDiskUsageInfo.thrift_spec)), None, ), # 5
  )

  def __init__(self, docsNum=None, cacheInfo=None, jvmInfo=None, indexNames=None, fileUsedInfos=None,):
    self.docsNum = docsNum
    self.cacheInfo = cacheInfo
    self.jvmInfo = jvmInfo
    self.indexNames = indexNames
    self.fileUsedInfos = fileUsedInfos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.docsNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.cacheInfo = CacheInfo()
          self.cacheInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.jvmInfo = JVMInfo()
          self.jvmInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.indexNames = []
          (_etype77, _size74) = iprot.readListBegin()
          for _i78 in xrange(_size74):
            _elem79 = iprot.readString();
            self.indexNames.append(_elem79)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.fileUsedInfos = []
          (_etype83, _size80) = iprot.readListBegin()
          for _i84 in xrange(_size80):
            _elem85 = FileDiskUsageInfo()
            _elem85.read(iprot)
            self.fileUsedInfos.append(_elem85)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LindenServiceInfo')
    if self.docsNum != None:
      oprot.writeFieldBegin('docsNum', TType.I32, 1)
      oprot.writeI32(self.docsNum)
      oprot.writeFieldEnd()
    if self.cacheInfo != None:
      oprot.writeFieldBegin('cacheInfo', TType.STRUCT, 2)
      self.cacheInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.jvmInfo != None:
      oprot.writeFieldBegin('jvmInfo', TType.STRUCT, 3)
      self.jvmInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.indexNames != None:
      oprot.writeFieldBegin('indexNames', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.indexNames))
      for iter86 in self.indexNames:
        oprot.writeString(iter86)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fileUsedInfos != None:
      oprot.writeFieldBegin('fileUsedInfos', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.fileUsedInfos))
      for iter87 in self.fileUsedInfos:
        iter87.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      if self.docsNum is None:
        raise TProtocol.TProtocolException(message='Required field docsNum is unset!')
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
